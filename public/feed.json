{"version":"https://jsonfeed.org/version/1","title":"Anas Mohamed","home_page_url":"https://amohamed.io","feed_url":"https://amohamed.io/feed.json","description":"Anecdotal Thoughts","icon":"favicon.ico","favicon":"<no value>","expired":false,"author":{"name":"Anas Mohamed","url":"https://amohamed.io"},"items":[{"id":"3e79b96491ebab4b5cef7f6ab6d59c5209062f45","title":"Building a Lightweight Key-Value Database in Go","summary":"On-disk B+trees \u0026 other midly extreme sports.","content_text":"This will be more of a high-level technical overview of key-value database design using notes from my research while working on Kagi, a on-disk key-value store.\nAt the bottom are some fantastic resources for better understanding B+Trees and Key-Value store design, definitely check those out.\nWhy build Kagi? # About a year and a half ago, I decided to take Databases II. And as soon as the first assignment, a run-of-the-mill embedded SQL assignment, was released, I remember thinking \u0026ldquo;why can\u0026rsquo;t we just create a database instead\u0026rdquo;. So this past holiday, I thought I\u0026rsquo;d finally sit down and do just that.\nDatabase design, and why a KV database? # For this, ironically, I ended up pulling out my lecture notes from said Databases II class. Despite the dreadful assignments, this course did touch on some essential concepts of database design. Here is the bullet-point summary:\n Accessing the data (on-disk vs in-memory, ordered vs unordered, etc.) Executing queries (SQL compiler, query optimizer, etc.) Managing transactions (ACID, scheduling, batching, etc.) Maintaining the database (index updates, tombstone cleanup, etc.)  As you can already probably tell, databases can get pretty complicated.\nThankfully for a simple key-value database, we can focus on the first \u0026amp; the last parts to create a fully functional key-value store. And given my familiarity with B+Tree, it was an obvious choice for data access \u0026amp; organization to allow me to focus on the on-disk aspect. I would definitely\nRepresenting a database connection # To begin with, we create a struct that encompasses all the necessary attributes for a Kagi DB connection. First thing is the DB file itself. Second, we track the root node for our B+Tree. We also have a single mutex to make sure that changes to the DB file are synchronized. Lastly we have our loggers, one for general info, the other for fatal errors. With that we have this representation for a DB connection\ntype DB_CONNECTION struct { sync.Mutex file *os.File filePath string root *Node count uint32 infoLogger *log.Logger errorLogger *log.Logger }  Hear me out, B+Tree \u0026hellip; but on-disk.ü§Ø # Since our B+Tree will be on disk, we have to deal with 2 integral changes to the traditional in-memory representation. The first is offsets instead of pointers, and the second is working with bytes instead of abstractions. Unix has a block size of 4096 bytes, as such we structure our B+Tree around that block size. To start off I settled on an Order=20 and a Degree=10 (Order is our upper limit for a Node\u0026rsquo;s bucket, and Degree is our lower limit) for the B+Tree. So this means we can fit a max of 19 key-value pairs in a 4KB node.\nHere is an early sketch of a Node as I was considering what headers are necessary, and how many bytes each part required. All elements of the header use either uint16 (2 bytes) or uint32 (4 bytes) as there is no need for negatives for boolean flags or for counts.\nAfter deciding on the headers, I settled on about 192 bytes for the key-value pairs. Where keys ar 48 bytes and values are 144 bytes. With that here is the set of constraints utilized in Kagi to make sure we are maximizing what we can get out of the 4KB blocks.\nconst ( Order int32 = 20 // the upper limit for number of keys/values that node can hold Degree int32 = 10 // the lower limit for number of keys/values that node must hold BlockSize int32 = 4096 // max size of a node Int32Size int32 = 4 // size of uint32 used for offsets in node Int16Size int32 = 2 // size of uint16 used for flags and counts in nodes MaxKeySize int32 = 48 MaxValueSize int32 = 144 )  Constructing our node # With our byte constraints set, we can setup our Node structure. One of the more confusing aspects of this project was in fact managing all the offsets necessary. In the end, it took some trial \u0026amp; error to figure out which offsets were necessary, and which were just waste of space.\nAs in all B+Trees, we will have two types of nodes:\n Branching Node: holds a bucket of keys to direct us in the tree Leaf Node: holds a bucket of key-value pairs  Both type of nodes have the same headers, but different buckets. These headers are used to tell us about the state (leaf count, deleted marker, etc.). If a node ever has child offsets then we know that we it is a branching node, otherwise it\u0026rsquo;s a leaf node.\ntype Node struct { //----Header---- // Flags isRoot uint16 isDeleted uint16 // Counts dbCount uint32 numKeys uint16 numLeaves uint16 // Offsets offset uint32 parentOffset uint32 childOffsets []uint32 // ------------- // branching node keys [][]byte // leaf nodes leaves []*Leaf } type Leaf struct { // data key []byte value []byte }  But first, some tests # With the Node struct done, we can start on B+Tree operations. But first, tests. Below is a simple test for setting/getting 100 key-value pairs. The test generates random values to use for key \u0026amp; value, each 5 bytes.\nfunc TestSet100Keys(t *testing.T) { db := Open(testClearOptions) rand.Seed(time.Now().UnixNano()) seq := randSeq(1000) for i := 0; i \u0026lt; 1000; i += 10 { k := seq[i : i+5] v := seq[i+5 : i+10] err := db.Set(k, v) db.logError(err) } db.Close() } func TestGet100Keys(t *testing.T) { ... // Same as test for Set ... for i := 0; i \u0026lt; 1000; i += 10 { k := seq[i : i+5] v := seq[i+5 : i+10] found, err2 := db.Get(k) if found != v { t.Error(err2) t.Errorf(`test %d, actual: \u0026quot;%s\u0026quot;, expected: \u0026quot;%s\u0026quot;`, i/10, found, v) } } db.Close() }  Now, thanks to TDD, we work on flipping those failing tests upside down.\nTraversing the on-disk tree # First operation up is tree traversal. Traversing the on-disk B+tree is pretty similar to in-memory, with a slight twist, offsets. You start at the root node (which the DB always knows), then recursively traverse using child offsets - instead of pointers - with keys as direction markers. Below is a representation of our B+Tree.\nUpdating the on-disk tree # Now that we can freely traverse our tree, we move onto updating it. For adding a new key-value pair, we first find which node it fits into by traversing the tree. Once we insert the new data in the node\u0026rsquo;s bucket, there are 2 scenarios:\n If it\u0026rsquo;s not full, then we are done. If it\u0026rsquo;s full, then we have to split the node up.  Splitting a node up # If we ever fill up a node (number of keys equal Order), we split up the node into 3 nodes. In summary follow this basic algorithm:\n Splits leaves into 3 parts. Middle becomes a branching node. Left \u0026amp; Right become child nodes of the Middle. Add middle node as child to parent. If parent is now full, split parent node as well.  Run it back ‚úîÔ∏è # With the traversal \u0026amp; updates for our B+Tree implemented - code too long to showcase here - we can now run our tests (added a test to make sure everything was saved on exit) to get those sweet, sweet passes.\nOn next episode # We got just two things left, and we got a fully functional key-value database, deletion \u0026amp; index maintenance. I plan to wrap up this features soon, and perhaps add a \u0026ldquo;Space\u0026rdquo; functionality to group a set of keys together. But this we\u0026rsquo;ll have to do for now.\n\nIf you\u0026rsquo;ve read this far, first of all thank you. Second, if you have any feedback please do feel free to hit me up about it, I\u0026rsquo;d really appreciate it.\nResources: #  A fantastic B+Tree visualizer: https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html Chapter from \u0026ldquo;Database Internals\u0026rdquo; by Alex Petrov on implementing on-disk B+Tree: https://www.oreilly.com/library/view/database-internals/9781492040330/ch04.html Look into B+Tree indexing in Oracle: http://web.archive.org/web/20161221112438/http://www.toadworld.com/platforms/oracle/w/wiki/11001.oracle-b-tree-index-from-the-concept-to-internals  ","content_html":"\u003cp\u003eThis will be more of a high-level technical overview of key-value database design using notes from my research while working on \u003ca href=\"https://github.com/amohamed11/kagi\"\u003eKagi\u003c/a\u003e, a on-disk key-value store.\u003c/p\u003e\n\u003cp\u003eAt the bottom are some fantastic resources for better understanding B+Trees and Key-Value store design, definitely check those out.\u003c/p\u003e\n\u003ch2 id=\"why-build-kagi\"\u003eWhy build Kagi? \u003ca href=\"#why-build-kagi\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAbout a year and a half ago, I decided to take Databases II. And as soon as the first assignment, a run-of-the-mill embedded SQL assignment, was released, I remember thinking \u0026ldquo;why can\u0026rsquo;t we just create a database instead\u0026rdquo;. So this past holiday, I thought I\u0026rsquo;d finally sit down and do just that.\u003c/p\u003e\n\u003ch2 id=\"database-design-and-why-a-kv-database\"\u003eDatabase design, and why a KV database? \u003ca href=\"#database-design-and-why-a-kv-database\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/img/kv.png\" alt=\"Representation of a Key-Value database\" loading=\"lazy\" /\u003e\n\u003c/p\u003e\n\u003cp\u003eFor this, ironically, I ended up pulling out my lecture notes from said Databases II class. Despite the dreadful assignments, this course did touch on some essential concepts of database design. Here is the bullet-point summary:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAccessing the data (on-disk vs in-memory, ordered vs unordered, etc.)\u003c/li\u003e\n\u003cli\u003eExecuting queries (SQL compiler, query optimizer, etc.)\u003c/li\u003e\n\u003cli\u003eManaging transactions (ACID, scheduling, batching, etc.)\u003c/li\u003e\n\u003cli\u003eMaintaining the database (index updates, tombstone cleanup, etc.)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAs you can already probably tell, databases can get pretty complicated.\u003c/p\u003e\n\u003cp\u003eThankfully for a simple key-value database, we can focus on the first \u0026amp; the last parts to create a fully functional key-value store. And given my familiarity with B+Tree, it was an obvious choice for data access \u0026amp; organization to allow me to focus on the on-disk aspect. I would definitely\u003c/p\u003e\n\u003ch2 id=\"representing-a-database-connection\"\u003eRepresenting a database connection \u003ca href=\"#representing-a-database-connection\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eTo begin with, we create a struct that encompasses all the necessary attributes for a Kagi DB connection. First thing is the DB file itself. Second, we track the root node for our B+Tree. We also have a single mutex to make sure that changes to the DB file are synchronized. Lastly we have our loggers, one for general info, the other for fatal errors. With that we have this representation for a DB connection\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype DB_CONNECTION struct {\n\tsync.Mutex\n\tfile        *os.File\n\tfilePath    string\n\troot        *Node\n\tcount       uint32\n\tinfoLogger  *log.Logger\n\terrorLogger *log.Logger\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"hear-me-out-btree--but-on-disk\"\u003eHear me out, B+Tree \u0026hellip; but on-disk.ü§Ø \u003ca href=\"#hear-me-out-btree--but-on-disk\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSince our B+Tree will be on disk, we have to deal with 2 integral changes to the traditional in-memory representation. The first is offsets instead of pointers, and the second is working with bytes instead of abstractions.  Unix has a block size of \u003ccode\u003e4096 bytes\u003c/code\u003e, as such we structure our B+Tree around that block size. To start off I settled on an \u003ccode\u003eOrder=20\u003c/code\u003e and a \u003ccode\u003eDegree=10\u003c/code\u003e (Order is our upper limit for a Node\u0026rsquo;s bucket, and Degree is our lower limit) for the B+Tree. So this means we can fit a max of 19 key-value pairs in a 4KB node.\u003c/p\u003e\n\u003cp\u003eHere is an early sketch of a Node as I was considering what headers are necessary, and how many bytes each part required. All elements of the header use either \u003ccode\u003euint16\u003c/code\u003e (2 bytes) or \u003ccode\u003euint32\u003c/code\u003e (4 bytes) as there is no need for negatives for boolean flags or for counts.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/node.png\" alt=\"Representation of a Node\" loading=\"lazy\" /\u003e\n\u003c/p\u003e\n\u003cp\u003eAfter deciding on the headers, I settled on about 192 bytes for the key-value pairs. Where keys ar 48 bytes and values are 144 bytes. With that here is the set of constraints utilized in Kagi to make sure we are maximizing what we can get out of the 4KB blocks.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003econst (\n\tOrder        int32 = 20   // the upper limit for number of keys/values that node can hold\n\tDegree       int32 = 10   // the lower limit for number of keys/values that node must hold\n\tBlockSize    int32 = 4096 // max size of a node\n\tInt32Size    int32 = 4    // size of uint32 used for offsets in node\n\tInt16Size    int32 = 2    // size of uint16 used for flags and counts in nodes\n\tMaxKeySize   int32 = 48\n\tMaxValueSize int32 = 144\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"constructing-our-node\"\u003eConstructing our node \u003ca href=\"#constructing-our-node\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWith our byte constraints set, we can setup our Node structure. One of the more confusing aspects of this project was in fact managing all the offsets necessary. In the end, it took some trial \u0026amp; error to figure out which offsets were necessary, and which were just waste of space.\u003c/p\u003e\n\u003cp\u003eAs in all B+Trees, we will have two types of nodes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBranching Node: holds a bucket of keys to direct us in the tree\u003c/li\u003e\n\u003cli\u003eLeaf Node: holds a bucket of key-value pairs\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBoth type of nodes have the same headers, but different buckets. These headers are used to tell us about the state (leaf count, deleted marker, etc.). If a node ever has child offsets then we know that we it is a branching node, otherwise it\u0026rsquo;s a leaf node.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype Node struct {\n\t//----Header----\n\t// Flags\n\tisRoot    uint16\n\tisDeleted uint16\n\n\t// Counts\n\tdbCount   uint32\n\tnumKeys   uint16\n\tnumLeaves uint16\n\n\t// Offsets\n\toffset       uint32\n\tparentOffset uint32\n\tchildOffsets []uint32\n\t// -------------\n\n\t// branching node\n\tkeys [][]byte\n\n\t// leaf nodes\n\tleaves []*Leaf\n}\n\ntype Leaf struct {\n\t// data\n\tkey   []byte\n\tvalue []byte\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"but-first-some-tests\"\u003eBut first, some tests \u003ca href=\"#but-first-some-tests\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWith the Node struct done, we can start on B+Tree operations. But first, tests. Below is a simple test for setting/getting 100 key-value pairs. The test generates random values to use for key \u0026amp; value, each 5 bytes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc TestSet100Keys(t *testing.T) {\n\tdb := Open(testClearOptions)\n\trand.Seed(time.Now().UnixNano())\n\tseq := randSeq(1000)\n\n\tfor i := 0; i \u0026lt; 1000; i += 10 {\n\t\tk := seq[i : i+5]\n\t\tv := seq[i+5 : i+10]\n\n\t\terr := db.Set(k, v)\n\t\tdb.logError(err)\n\t}\n\tdb.Close()\n}\n\nfunc TestGet100Keys(t *testing.T) {\n    ...\n\t// Same as test for Set\n    ...\n\n\tfor i := 0; i \u0026lt; 1000; i += 10 {\n\t\tk := seq[i : i+5]\n\t\tv := seq[i+5 : i+10]\n\n\t\tfound, err2 := db.Get(k)\n\t\tif found != v {\n\t\t\tt.Error(err2)\n\t\t\tt.Errorf(`test %d, actual: \u0026quot;%s\u0026quot;, expected: \u0026quot;%s\u0026quot;`, i/10, found, v)\n\t\t}\n\t}\n\tdb.Close()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, thanks to TDD, we work on flipping those failing tests upside down.\u003c/p\u003e\n\u003ch2 id=\"traversing-the-on-disk-tree\"\u003eTraversing the on-disk tree \u003ca href=\"#traversing-the-on-disk-tree\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFirst operation up is tree traversal. Traversing the on-disk B+tree is pretty similar to in-memory, with a slight twist, offsets. You start at the root node (which the DB always knows), then recursively traverse using child offsets - instead of pointers - with keys as direction markers.  Below is a representation of our B+Tree.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/tree.png\" alt=\"Representation of the tree\" loading=\"lazy\" /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"updating-the-on-disk-tree\"\u003eUpdating the on-disk tree \u003ca href=\"#updating-the-on-disk-tree\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNow that we can freely traverse our tree, we move onto updating it. For adding a new key-value pair, we first find which node it fits into by traversing the tree. Once we insert the new data in the node\u0026rsquo;s bucket, there are 2 scenarios:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIf it\u0026rsquo;s not full, then we are done.\u003c/li\u003e\n\u003cli\u003eIf it\u0026rsquo;s full, then we have to split the node up.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"splitting-a-node-up\"\u003eSplitting a node up \u003ca href=\"#splitting-a-node-up\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIf we ever fill up a node (number of keys equal \u003ccode\u003eOrder\u003c/code\u003e), we split up the node into 3 nodes. In summary follow this basic algorithm:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSplits leaves into 3 parts.\u003c/li\u003e\n\u003cli\u003eMiddle becomes a branching node.\u003c/li\u003e\n\u003cli\u003eLeft \u0026amp; Right become child nodes of the Middle.\u003c/li\u003e\n\u003cli\u003eAdd middle node as child to parent.\u003c/li\u003e\n\u003cli\u003eIf parent is now full, split parent node as well.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"run-it-back-\"\u003eRun it back ‚úîÔ∏è \u003ca href=\"#run-it-back-\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWith the traversal \u0026amp; updates for our B+Tree implemented - code too long to showcase here - we can now run our tests (added a test to make sure everything was saved on exit) to get those sweet, sweet passes.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/tests_pass.png\" alt=\"Passing tests\" loading=\"lazy\" /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"on-next-episode\"\u003eOn next episode \u003ca href=\"#on-next-episode\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe got just two things left, and we got a fully functional key-value database, deletion \u0026amp; index maintenance. I plan to wrap up this features soon, and perhaps add a \u0026ldquo;Space\u0026rdquo; functionality to group a set of keys together. But this we\u0026rsquo;ll have to do for now.\u003c/p\u003e\n\u003cp\u003e\u003cbr\u003e\nIf you\u0026rsquo;ve read this far, first of all thank you. Second, if you have any feedback please do feel free to hit me up about it, I\u0026rsquo;d really appreciate it.\u003c/p\u003e\n\u003ch2 id=\"resources\"\u003eResources: \u003ca href=\"#resources\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eA fantastic B+Tree visualizer: \u003ca href=\"https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\"\u003ehttps://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eChapter from \u0026ldquo;Database Internals\u0026rdquo; by Alex Petrov on implementing on-disk B+Tree: \u003ca href=\"https://www.oreilly.com/library/view/database-internals/9781492040330/ch04.html\"\u003ehttps://www.oreilly.com/library/view/database-internals/9781492040330/ch04.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLook into B+Tree indexing in Oracle: \u003ca href=\"http://web.archive.org/web/20161221112438/http://www.toadworld.com/platforms/oracle/w/wiki/11001.oracle-b-tree-index-from-the-concept-to-internals\"\u003ehttp://web.archive.org/web/20161221112438/http://www.toadworld.com/platforms/oracle/w/wiki/11001.oracle-b-tree-index-from-the-concept-to-internals\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","url":"https://amohamed.io/building-a-lightweight-key-value-database-in-go/","image":"https://amohamed.iophotos/<no value>","banner_image":"https://amohamed.iophotos/<no value>","date_published":"18056-18-09T512:1818:00+00:00","date_modified":"18056-18-09T512:1818:00+00:00","author":{"name":"Anas Mohamed","url":"https://amohamed.io"}},{"id":"32db984adfca3bde690bce1167a7f27af4a4c07f","title":"Things I Liked in 2020 (So far)","summary":"Ah nothing but good times.","content_text":"This year has been something. Still though, I want to start of this blogging thing on a good note. So, here is a compilation of things that I got to enjoy in 2020 so far.\nProgramming Talks # Every once and a while I go on a tech talk binge. Below are some of my recent favorites. Some I have watched for the first time in this year regardless of when they came out.\nThe Art of Code # \nLike most programmers, I think of coding only in the context of productivity. Whether it be work, school, or side projects, they are done for an external benefit or to solve a problem. Dylan Beattie instead explores coding as an art medium. He goes through many examples of the wild things that people have created. My favorite being the Quine Relay, a program that generates a program in different programming language which itself does the same for a continuous cycle that cover 128 programming languages.\nThis talk is just non-stop mind-blowing demonstrations of human creativity in this tech era.\nClean Code - Uncle Bob # \nA series of 6 lessons by Robert C. Martin (affectionately referred to as Uncle Bob). I just started on this series of lessons recently, but as always listening to Uncle Bob is nothing short of mesmerizing. There are few in the industry with the knowledge and expertise in software development like Uncle Bob, and even fewer that articulate that knowledge as well as he does.\nIf you are unfamiliar with Uncle Bob, I recommend checking out his book Clean Code and my favorite talk of his The Scribe\u0026rsquo;s Oath.\nCompilers For Nothing, Executables For Free! # \nLastly, a short (coming in at 8 minutes only) and fun talk that descends down the rabbit-hole that is specializers (specialized interpreters), all in the name of what\u0026rsquo;s right \u0026amp; Vim.\nVideo Games # Most of these games came out last year, but I was only able to get around to them this year. Also as a rule, I decided to only include single-player games, as such no Valorant (which I sunk an ungodly amount of time into), Among Us, etc.\nOuter Wilds # With the risk of sounding hyperbolic, this is probably my favorite game of all-time now. And that statement has remained the same since I finished it in January. The way Outer Wilds interweaves story and exploration in such a unique and delightful manner is an experience to be had.\nPersonally I\u0026rsquo;ve never been one for exploration, but that was because usually that directly interfered with my progress in the story. Exploring for the sake of exploring - though fun - just doesn;t strike me as enjoyable as unpeeling a good storyline is. And Outer Wilds manages to combine exploration directly with the story. So this way, you are rewarded two-fold when you explore, once for the amazing and unique planetary design that is a scene to behold, and once for the story bits that you pick up on along the way.\nOverall, Outer Wilds is just an absolute masterpiece in narrative and non-linear story-telling. And to me it is a testement to the unique storytelling capabilities of video games. I simply cannot recommend this game enough.\nBaba Is You # Also an Indie darling from 2019, Baba Is You manages to make puzzle games - typically my least favorite genre - fun for me. A simple but mind-bogglingly innovative gameplay coupled with tight level design and just the most adorable protagonist, what else can you ask for.\nBaba Is You isn\u0026rsquo;t the type of game you \u0026ldquo;finish\u0026rdquo; thanks to the plethora of levels (about 200) or at least that is if you are as bad as I am with puzzles.\nInstead it is the kind of game that you pop on every once and a while and solve as few levels before your brain melts and you get stuck and call it a night lest you give into googling a walkthrough. But god is it satisfying to figure out these puzzles, they truly force you to think outside the box and it just so good at it doing it consistently.\nHades # Lastly, Hades, a game that actually this year (if you ignore that it was in early access for a year).\nI\u0026rsquo;m still working through this game currently, but I can sing it nothing but praises. This game is truly embodies the meaning of polish. Every single part is just fantastic, from combat, voice-acting, to character design and storytelling. Hades just goes above and beyond to rewarding you for having a good or a bad run. The timings of when you unlock new upgrades is so well tuned, that you never feel stuck for too long. And when you die, you have often new dialogue and (sometimes) story to look forward to.\nIn a twisted way, Supergiant Games made dying in Hades somehow a truly enjoyable experience. If that sounds up your ally, than definitely give this a try, cause I truly believe there is something in this game for everyone to enjoy.\nTo be continued # This article has gotten longer than I had anticipated, so I\u0026rsquo;ll call it here for now. But, I will append a part 2 to this before the year ends, with more things I enjoyed including Blogs, Books, TV/Movie, and Anime. Hopefully with more recent \u0026amp; fresh things to rave about next time.\n","content_html":"\u003cp\u003eThis year has been something. Still though, I want to start of this blogging thing on a good note. So, here is a compilation of things that I got to enjoy in 2020 so far.\u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003ch2 id=\"programming-talks\"\u003eProgramming Talks \u003ca href=\"#programming-talks\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eEvery once and a while I go on a tech talk binge. Below are some of my recent favorites. Some I have watched for the first time in this year regardless of when they came out.\u003c/p\u003e\n\u003ch3 id=\"the-art-of-code\"\u003eThe Art of Code \u003ca href=\"#the-art-of-code\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=6avJHaC3C2U\"\u003e\u003cimg src=\"https://i1.ytimg.com/vi/6avJHaC3C2U/hqdefault.jpg\" alt=\"Thumbnail for The Art of Code video\" loading=\"lazy\" /\u003e\n\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLike most programmers, I think of coding only in the context of productivity. Whether it be work, school, or side projects, they are done for an external benefit or to solve a problem. Dylan Beattie instead explores coding as an art medium. He goes through many examples of the wild things that people have created. My favorite being the Quine Relay, a program that generates a program in different programming language which itself does the same for a continuous cycle that cover 128 programming languages.\u003cbr\u003e\nThis talk is just non-stop mind-blowing demonstrations of human creativity in this tech era.\u003c/p\u003e\n\u003ch3 id=\"clean-code---uncle-bob\"\u003eClean Code - Uncle Bob \u003ca href=\"#clean-code---uncle-bob\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=7EmboKQH8lM\"\u003e\u003cimg src=\"https://i.ytimg.com/vi_webp/7EmboKQH8lM/maxresdefault.webp\" alt=\"Thumbnail for Clean Code - Uncle Bob Video\" loading=\"lazy\" /\u003e\n\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eA series of 6 lessons by Robert C. Martin (affectionately referred to as Uncle Bob). I just started on this series of lessons recently, but as always listening to Uncle Bob is nothing short of mesmerizing. There are few in the industry with the knowledge and expertise in software development like Uncle Bob, and even fewer that articulate that knowledge as well as he does.\u003cbr\u003e\nIf you are unfamiliar with Uncle Bob, I recommend checking out his book \u003ca href=\"https://www.goodreads.com/book/show/3735293-clean-code\"\u003eClean Code\u003c/a\u003e and my favorite talk of his \u003ca href=\"https://www.youtube.com/watch?v=Tng6Fox8EfI\"\u003eThe Scribe\u0026rsquo;s Oath\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"compilers-for-nothing-executables-for-free\"\u003eCompilers For Nothing, Executables For Free! \u003ca href=\"#compilers-for-nothing-executables-for-free\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=Dcug6bu_wUE\"\u003e\u003cimg src=\"https://i.ytimg.com/vi_webp/Dcug6bu_wUE/maxresdefault.webp\" alt=\"Thumbnail for Compilers For Nothing, Executables For Free! Video\" loading=\"lazy\" /\u003e\n\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLastly, a short (coming in at 8 minutes only) and fun talk that descends down the rabbit-hole that is specializers (specialized interpreters), all in the name of what\u0026rsquo;s right \u0026amp; Vim.\u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003ch2 id=\"video-games\"\u003eVideo Games \u003ca href=\"#video-games\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eMost of these games came out last year, but I was only able to get around to them this year. Also as a rule, I decided to only include single-player games, as such no Valorant (which I sunk an ungodly amount of time into), Among Us, etc.\u003c/p\u003e\n\u003ch3 id=\"outer-wilds\"\u003eOuter Wilds \u003ca href=\"#outer-wilds\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWith the risk of sounding hyperbolic, this is probably my favorite game of all-time now. And that statement has remained the same since I finished it in January. The way Outer Wilds interweaves story and exploration in such a unique and delightful manner is an experience to be had.\u003c/p\u003e\n\u003cp\u003ePersonally I\u0026rsquo;ve never been one for exploration, but that was because usually that directly interfered with my progress in the story. Exploring for the sake of exploring - though fun - just doesn;t strike me as enjoyable as unpeeling a good storyline is. And Outer Wilds manages to combine exploration directly with the story. So this way, you are rewarded two-fold when you explore, once for the amazing and unique planetary design that is a scene to behold, and once for the story bits that you pick up on along the way.\u003c/p\u003e\n\u003cp\u003eOverall, Outer Wilds is just an absolute masterpiece in narrative and non-linear story-telling. And to me it is a testement to the unique storytelling capabilities of video games. I simply cannot recommend this game enough.\u003c/p\u003e\n\u003ch3 id=\"baba-is-you\"\u003eBaba Is You \u003ca href=\"#baba-is-you\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAlso an Indie darling from 2019, Baba Is You manages to make puzzle games - typically my least favorite genre - fun for me. A simple but mind-bogglingly innovative gameplay coupled with tight level design and just the most adorable protagonist, what else can you ask for.\u003cbr\u003e\nBaba Is You isn\u0026rsquo;t the type of game you \u0026ldquo;finish\u0026rdquo; thanks to the plethora of levels (about 200) or at least that is if you are as bad as I am with puzzles.\u003cbr\u003e\nInstead it is the kind of game that you pop on every once and a while and solve as few levels before your brain melts and you get stuck and call it a night lest you give into googling a walkthrough. But god is it satisfying to figure out these puzzles, they truly force you to think outside the box and it just so good at it doing it consistently.\u003c/p\u003e\n\u003ch3 id=\"hades\"\u003eHades \u003ca href=\"#hades\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLastly, Hades, a game that actually this year (if you ignore that it was in early access for a year).\u003cbr\u003e\nI\u0026rsquo;m still working through this game currently, but I can sing it nothing but praises. This game is truly embodies the meaning of polish. Every single part is just fantastic, from combat, voice-acting, to character design and storytelling. Hades just goes above and beyond to rewarding you for having a good or a bad run. The timings of when you unlock new upgrades is so well tuned, that you never feel stuck for too long. And when you die, you have often new dialogue and (sometimes) story to look forward to.\u003cbr\u003e\nIn a twisted way, Supergiant Games made dying in Hades somehow a truly enjoyable experience. If that sounds up your ally, than definitely give this a try, cause I truly believe there is something in this game for everyone to enjoy.\u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003ch2 id=\"to-be-continued\"\u003eTo be continued \u003ca href=\"#to-be-continued\" class=\"hash\"\u003e#\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThis article has gotten longer than I had anticipated, so I\u0026rsquo;ll call it here for now. But, I will append a part 2 to this before the year ends, with more things I enjoyed including Blogs, Books, TV/Movie, and Anime. Hopefully with more recent \u0026amp; fresh things to rave about next time.\u003c/p\u003e\n","url":"https://amohamed.io/things-liked-2020/","image":"https://amohamed.iophotos/<no value>","banner_image":"https://amohamed.iophotos/<no value>","date_published":"11116-11-09T110:1111:00+00:00","date_modified":"11116-11-09T110:1111:00+00:00","author":{"name":"Anas Mohamed","url":"https://amohamed.io"}}]}