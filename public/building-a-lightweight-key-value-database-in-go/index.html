<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="Anas Mohamed - https://amohamed.io">
<title>Building a Lightweight Key-Value Database in Go | Anas Mohamed</title>
<meta name=description content="On-disk B+trees & other midly extreme sports.">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Building a Lightweight Key-Value Database in Go">
<meta name=twitter:description content="On-disk B+trees & other midly extreme sports.">
<meta property="og:title" content="Building a Lightweight Key-Value Database in Go">
<meta property="og:description" content="On-disk B+trees & other midly extreme sports.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://amohamed.io/building-a-lightweight-key-value-database-in-go/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-05-18T23:12:25+00:00">
<meta property="article:modified_time" content="2021-05-18T23:12:25+00:00">
<meta itemprop=name content="Building a Lightweight Key-Value Database in Go">
<meta itemprop=description content="On-disk B+trees & other midly extreme sports."><meta itemprop=datePublished content="2021-05-18T23:12:25+00:00">
<meta itemprop=dateModified content="2021-05-18T23:12:25+00:00">
<meta itemprop=wordCount content="1311">
<meta itemprop=keywords content="project,databases,go,">
<link rel=canonical href=https://amohamed.io/building-a-lightweight-key-value-database-in-go/>
<link rel=dns-prefetch href=https://www.google-analytics.com>
<link href=https://www.google-analytics.com rel=preconnect crossorigin>
<link rel=alternate type=application/atom+xml title="Anas Mohamed" href=https://amohamed.ioatom.xml>
<link rel=alternate type=application/json title="Anas Mohamed" href=https://amohamed.iofeed.json>
<link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=">
<style>*,:after,:before{box-sizing:border-box;padding:0}@font-face{font-family:myFirstFont;src:url(AnonymousPro-Regular.ttf)}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeSpeed}.posts hr{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:none;border-bottom:1px #353535;flex:1 0 1rem}main{max-width:70ch;padding:2ch;margin:auto}a,body{color:#353535}::selection,a:focus,a:hover{background-color:#353535;color:#fff}.meta{margin:0 0 2.5rem}.tags::before{content:"\2022";margin-left:1rem}code,pre{color:#353535;font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;border:1px solid #353535;font-size:small}code{padding:.1rem;border:none}pre{padding:.5rem;overflow-x:auto}pre code{border:none}img{max-width:100%;border:1px solid #353535}hr{background:#353535;height:1px;border:0}ul{list-style-type:square}ul,ol{padding-left:1.2rem}header li,footer li{display:inline;text-transform:uppercase}header a,footer a{text-decoration:none}header ul,footer ul{justify-content:space-between;display:flex}[aria-current=page]{text-decoration:line-through}header,section,footer{padding:1rem 0}blockquote{border-left:5px solid #353535;padding-left:1rem}.posts ul,header ul,footer ul{list-style:none}.posts,header ul,footer ul{padding:0}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.7rem}.posts li a,.posts li div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}.hash{opacity:.25;text-decoration:none}table{border-collapse:collapse;text-align:left;width:100%}table tr{background:#fff;border-bottom:1px solid}table th,table td{padding:10px 20px}</style>
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Building a Lightweight Key-Value Database in Go","headline":"Building a Lightweight Key-Value Database in Go","alternativeHeadline":"","description":"On-disk B\u002btrees \u0026 other midly extreme sports.","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/amohamed.io\/building-a-lightweight-key-value-database-in-go\/"},"author":{"@type":"Person","name":"Anas Mohamed"},"creator":{"@type":"Person","name":"Anas Mohamed"},"accountablePerson":{"@type":"Person","name":"Anas Mohamed"},"copyrightHolder":"Anas Mohamed","copyrightYear":"2021","dateCreated":"2021-05-18T23:12:25.00Z","datePublished":"2021-05-18T23:12:25.00Z","dateModified":"2021-05-18T23:12:25.00Z","publisher":{"@type":"Organization","name":"Anas Mohamed","url":"https://amohamed.io","logo":{"@type":"ImageObject","url":"https:\/\/amohamed.io\/favicon.ico","width":"32","height":"32"}},"image":"https://amohamed.io/favicon.ico","url":"https:\/\/amohamed.io\/building-a-lightweight-key-value-database-in-go\/","wordCount":"1311","genre":["project","databases","go"],"keywords":["project","databases","go"]}</script>
</head>
<body>
<main>
<header>
<nav>
<ul>
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/about/>About</a>
</li>
<li>
<a href=/atom.xml>RSS</a>
</li>
</ul>
</nav>
</header>
<hr>
<section>
<h2 itemprop="name headline">Building a Lightweight Key-Value Database in Go</h2>
<p class=meta>
<time itemprop=datePublished datetime=2021-05-18> May 18, 2021</time> &bull;
<a href=/tags/project>Project</a>, <a href=/tags/databases>Databases</a>, <a href=/tags/go>Go</a>
</p>
<span itemprop=articleBody>
<p>This will be more of a high-level technical overview of key-value database design using notes from my research while working on <a href=https://github.com/amohamed11/kagi>Kagi</a>, a on-disk key-value store.</p>
<p>At the bottom are some fantastic resources for better understanding B+Trees and Key-Value store design, definitely check those out.</p>
<h2 id=why-build-kagi>Why build Kagi? <a href=#why-build-kagi class=hash>#</a></h2>
<p>About a year and a half ago, I decided to take Databases II. And as soon as the first assignment, a run-of-the-mill embedded SQL assignment, was released, I remember thinking &ldquo;why can&rsquo;t we just create a database instead&rdquo;. So this past holiday, I thought I&rsquo;d finally sit down and do just that.</p>
<h2 id=database-design-and-why-a-kv-database>Database design, and why a KV database? <a href=#database-design-and-why-a-kv-database class=hash>#</a></h2>
<p><img src=/img/kv.png alt="Representation of a Key-Value database" loading=lazy>
</p>
<p>For this, ironically, I ended up pulling out my lecture notes from said Databases II class. Despite the dreadful assignments, this course did touch on some essential concepts of database design. Here is the bullet-point summary:</p>
<ol>
<li>Accessing the data (on-disk vs in-memory, ordered vs unordered, etc.)</li>
<li>Executing queries (SQL compiler, query optimizer, etc.)</li>
<li>Managing transactions (ACID, scheduling, batching, etc.)</li>
<li>Maintaining the database (index updates, tombstone cleanup, etc.)</li>
</ol>
<p>As you can already probably tell, databases can get pretty complicated.</p>
<p>Thankfully for a simple key-value database, we can focus on the first & the last parts to create a fully functional key-value store. And given my familiarity with B+Tree, it was an obvious choice for data access & organization to allow me to focus on the on-disk aspect. I would definitely</p>
<h2 id=representing-a-database-connection>Representing a database connection <a href=#representing-a-database-connection class=hash>#</a></h2>
<p>To begin with, we create a struct that encompasses all the necessary attributes for a Kagi DB connection. First thing is the DB file itself. Second, we track the root node for our B+Tree. We also have a single mutex to make sure that changes to the DB file are synchronized. Lastly we have our loggers, one for general info, the other for fatal errors. With that we have this representation for a DB connection</p>
<pre><code class=language-go>type DB_CONNECTION struct {
	sync.Mutex
	file        *os.File
	filePath    string
	root        *Node
	count       uint32
	infoLogger  *log.Logger
	errorLogger *log.Logger
}
</code></pre>
<h2 id=hear-me-out-btree--but-on-disk>Hear me out, B+Tree &mldr; but on-disk.ü§Ø <a href=#hear-me-out-btree--but-on-disk class=hash>#</a></h2>
<p>Since our B+Tree will be on disk, we have to deal with 2 integral changes to the traditional in-memory representation. The first is offsets instead of pointers, and the second is working with bytes instead of abstractions. Unix has a block size of <code>4096 bytes</code>, as such we structure our B+Tree around that block size. To start off I settled on an <code>Order=20</code> and a <code>Degree=10</code> (Order is our upper limit for a Node&rsquo;s bucket, and Degree is our lower limit) for the B+Tree. So this means we can fit a max of 19 key-value pairs in a 4KB node.</p>
<p>Here is an early sketch of a Node as I was considering what headers are necessary, and how many bytes each part required. All elements of the header use either <code>uint16</code> (2 bytes) or <code>uint32</code> (4 bytes) as there is no need for negatives for boolean flags or for counts.</p>
<p><img src=/img/node.png alt="Representation of a Node" loading=lazy>
</p>
<p>After deciding on the headers, I settled on about 192 bytes for the key-value pairs. Where keys ar 48 bytes and values are 144 bytes. With that here is the set of constraints utilized in Kagi to make sure we are maximizing what we can get out of the 4KB blocks.</p>
<pre><code class=language-go>const (
	Order        int32 = 20   // the upper limit for number of keys/values that node can hold
	Degree       int32 = 10   // the lower limit for number of keys/values that node must hold
	BlockSize    int32 = 4096 // max size of a node
	Int32Size    int32 = 4    // size of uint32 used for offsets in node
	Int16Size    int32 = 2    // size of uint16 used for flags and counts in nodes
	MaxKeySize   int32 = 48
	MaxValueSize int32 = 144
)
</code></pre>
<h2 id=constructing-our-node>Constructing our node <a href=#constructing-our-node class=hash>#</a></h2>
<p>With our byte constraints set, we can setup our Node structure. One of the more confusing aspects of this project was in fact managing all the offsets necessary. In the end, it took some trial & error to figure out which offsets were necessary, and which were just waste of space.</p>
<p>As in all B+Trees, we will have two types of nodes:</p>
<ul>
<li>Branching Node: holds a bucket of keys to direct us in the tree</li>
<li>Leaf Node: holds a bucket of key-value pairs</li>
</ul>
<p>Both type of nodes have the same headers, but different buckets. These headers are used to tell us about the state (leaf count, deleted marker, etc.). If a node ever has child offsets then we know that we it is a branching node, otherwise it&rsquo;s a leaf node.</p>
<pre><code class=language-go>type Node struct {
	//----Header----
	// Flags
	isRoot    uint16
	isDeleted uint16

	// Counts
	dbCount   uint32
	numKeys   uint16
	numLeaves uint16

	// Offsets
	offset       uint32
	parentOffset uint32
	childOffsets []uint32
	// -------------

	// branching node
	keys [][]byte

	// leaf nodes
	leaves []*Leaf
}

type Leaf struct {
	// data
	key   []byte
	value []byte
}
</code></pre>
<h2 id=but-first-some-tests>But first, some tests <a href=#but-first-some-tests class=hash>#</a></h2>
<p>With the Node struct done, we can start on B+Tree operations. But first, tests. Below is a simple test for setting/getting 100 key-value pairs. The test generates random values to use for key & value, each 5 bytes.</p>
<pre><code class=language-go>func TestSet100Keys(t *testing.T) {
	db := Open(testClearOptions)
	rand.Seed(time.Now().UnixNano())
	seq := randSeq(1000)

	for i := 0; i &lt; 1000; i += 10 {
		k := seq[i : i+5]
		v := seq[i+5 : i+10]

		err := db.Set(k, v)
		db.logError(err)
	}
	db.Close()
}

func TestGet100Keys(t *testing.T) {
    ...
	// Same as test for Set
    ...

	for i := 0; i &lt; 1000; i += 10 {
		k := seq[i : i+5]
		v := seq[i+5 : i+10]

		found, err2 := db.Get(k)
		if found != v {
			t.Error(err2)
			t.Errorf(`test %d, actual: &quot;%s&quot;, expected: &quot;%s&quot;`, i/10, found, v)
		}
	}
	db.Close()
}
</code></pre>
<p>Now, thanks to TDD, we work on flipping those failing tests upside down.</p>
<h2 id=traversing-the-on-disk-tree>Traversing the on-disk tree <a href=#traversing-the-on-disk-tree class=hash>#</a></h2>
<p>First operation up is tree traversal. Traversing the on-disk B+tree is pretty similar to in-memory, with a slight twist, offsets. You start at the root node (which the DB always knows), then recursively traverse using child offsets - instead of pointers - with keys as direction markers. Below is a representation of our B+Tree.</p>
<p><img src=/img/tree.png alt="Representation of the tree" loading=lazy>
</p>
<h2 id=updating-the-on-disk-tree>Updating the on-disk tree <a href=#updating-the-on-disk-tree class=hash>#</a></h2>
<p>Now that we can freely traverse our tree, we move onto updating it. For adding a new key-value pair, we first find which node it fits into by traversing the tree. Once we insert the new data in the node&rsquo;s bucket, there are 2 scenarios:</p>
<ol>
<li>If it&rsquo;s not full, then we are done.</li>
<li>If it&rsquo;s full, then we have to split the node up.</li>
</ol>
<h3 id=splitting-a-node-up>Splitting a node up <a href=#splitting-a-node-up class=hash>#</a></h3>
<p>If we ever fill up a node (number of keys equal <code>Order</code>), we split up the node into 3 nodes. In summary follow this basic algorithm:</p>
<ol>
<li>Splits leaves into 3 parts.</li>
<li>Middle becomes a branching node.</li>
<li>Left & Right become child nodes of the Middle.</li>
<li>Add middle node as child to parent.</li>
<li>If parent is now full, split parent node as well.</li>
</ol>
<h2 id=run-it-back->Run it back ‚úîÔ∏è <a href=#run-it-back- class=hash>#</a></h2>
<p>With the traversal & updates for our B+Tree implemented - code too long to showcase here - we can now run our tests (added a test to make sure everything was saved on exit) to get those sweet, sweet passes.</p>
<p><img src=/img/tests_pass.png alt="Passing tests" loading=lazy>
</p>
<h2 id=on-next-episode>On next episode <a href=#on-next-episode class=hash>#</a></h2>
<p>We got just two things left, and we got a fully functional key-value database, deletion & index maintenance. I plan to wrap up this features soon, and perhaps add a &ldquo;Space&rdquo; functionality to group a set of keys together. But this we&rsquo;ll have to do for now.</p>
<p><br>
If you&rsquo;ve read this far, first of all thank you. Second, if you have any feedback please do feel free to hit me up about it, I&rsquo;d really appreciate it.</p>
<h2 id=resources>Resources: <a href=#resources class=hash>#</a></h2>
<ul>
<li>A fantastic B+Tree visualizer: <a href=https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html>https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></li>
<li>Chapter from &ldquo;Database Internals&rdquo; by Alex Petrov on implementing on-disk B+Tree: <a href=https://www.oreilly.com/library/view/database-internals/9781492040330/ch04.html>https://www.oreilly.com/library/view/database-internals/9781492040330/ch04.html</a></li>
<li>Look into B+Tree indexing in Oracle: <a href=http://web.archive.org/web/20161221112438/http://www.toadworld.com/platforms/oracle/w/wiki/11001.oracle-b-tree-index-from-the-concept-to-internals>http://web.archive.org/web/20161221112438/http://www.toadworld.com/platforms/oracle/w/wiki/11001.oracle-b-tree-index-from-the-concept-to-internals</a></li>
</ul>
</span>
</section>
<hr>
<footer>
<nav>
<ul>
<li>
¬© 2021
</li>
</ul>
</nav>
</footer>
</main>
</body>
</html>